var $screen = screen(6,0)
var $pivot_io = 1
var $orescanner_io = 3
var $terrainscanner_io = 0

var $vscreen = virtualscreen(100,100)

var $radius = 6400000
var $ranges = 100
var $stepsize = 80000
var $offsetx : number
var $offsety : number
var $scale : number
var $distancefromcam = 100000000

var $A = 0
var $B = 0
var $C = 0

var $buffer = 0

var $x : number
var $y : number
var $z : number

var $xp : number
var $yp : number
var $zp = 200

var $i : number
var $j : number
var $k : number

var $opacity = 255
var $dot = color(255,255,255,255)

array $longitudes : number
array $latitudes : number

array $heightmap : number

function @setresolution()
	$stepsize = pi * $radius / $ranges

function @setradarsize()
	$scale = 1
function @setscreen()
	$offsetx = $screen.width / 2
	$offsety = $screen.height / 2


function @generatelonlat()
	for -17,18 ($u)
		$longitudes.append($u * 10 / 360 * 2 * pi)
	for -9,9 ($p)
		$latitudes.append($p *10 / 360 * 2 * pi)
		
		


function @calculateijk($lon:number , $lat:number) : text
	$i = $radius * sin($lon) * cos($lat)
	$j = $radius * sin($lat)
	$k = $radius * cos($lat) * cos($lon)
	return ".i{$i}.j{$j}.k{$k}"

function @calculatexyz($u:text)
	$x = $scale *  $j * sin($A) * sin($B) * cos($C) - $k * cos($A) * sin($B) * cos($C) + $j * cos($A) * sin($C) + $k * sin($A) * sin($C) + $i * cos($B) * cos($C)
	$y = $scale * $j * cos($A) * cos($C) + $k * sin($A) * cos($C) - $j * sin($A) * sin($B) * sin($C) + $k * cos($A) * sin($B) * sin($C) - $i * cos($B) * sin($C)
	$z = $distancefromcam + $scale * $k * cos($A) * cos($B) - $j * sin($A) * cos($B) + $i * sin($B)
	
	
function @calculateforsurface($lon:number,$lat:number) : text
	@calculatexyz(@calculateijk($lon , $lat))
	var $ooz = 1 / ($z + 0.001) 
	$yp = $offsety + $scale *$y * $zp * $ooz
	$xp = $offsetx + $scale *$x * $zp * $ooz
	if $ooz > $buffer
		$opacity = 255
	else
		$opacity = 0
	return text(".x{}.y{}",$xp,$yp)

function @displaysphere()
	$screen.blank()
	foreach $longitudes ($u , $lon)
		foreach $latitudes ($p , $lat)
			@calculateforsurface($lon,$lat)
			$dot = color(($lon + pi) / (2 * pi) * 255,0,(1 - ($lon + pi) / (2*pi)) * 255,255)
			#if $lon == 0
				#$dot = color(255,0,0,255)
			if $lat == 0
				$dot = color(255,255,255,255)
			#if $lon == pi
			#	$dot = color(0,255,0,255)
			#else
				#$dot = color($lon,255-$lon,0,$opacity)
			$screen.draw_point($xp, $yp, black)
			$screen.draw_point($xp, $yp, $dot)
	$A = $A + 0.01
	$B = $b + 0.01
	$C = $C + 0.0
	if $distancefromcam > $radius * 1.1
		$distancefromcam = $distancefromcam - 80000
	$vscreen.blank(red)
	var $testcolor = color(0,0,255,0)
	print($testcolor)
	print($screen.pixel(170,170))
		
		


function @terrainscanning ($r:number)
	repeat $r ($n)
		var $arclength = $stepsize * ($n+1)
		print($arclength)
		output_number($terrainscanner_io,$n, ($n+1)*$stepsize)
		var $terraindata = input_text($terrainscanner_io,$n)
		var $lat = $arclength * cos(input_number($pivot_io,0)* 2 * pi) / 6400000
		var $lon = $arclength * sin(input_number($pivot_io,0)* 2 * pi) / 6400000
		@calculateforsurface($lon,$lat)
		var $terraindot = color(0,255,0, clamp(abs($terraindata) / 3000 * 255, 0 , $opacity))
		if $terraindata < 0
			$terraindot = color(0,0,255, clamp(abs($terraindata) / 3000 * 255, 0 , $opacity))
		if $terraindata >= 0
			$terraindot = color(0,255,0, clamp(abs($terraindata) / 3000 * 255, 0 , $opacity))
		$screen.draw_point($xp, $yp, black)
		$screen.draw_point($xp, $yp, $terraindot)

	
function @scanning()
	@terrainscanning($ranges)
			
init
	@generatelonlat()
	@setscreen()
	@setradarsize()
	@setresolution()
	output_number($pivot_io,0,0.03)
update
	@displaysphere()
	#@scanning()	
